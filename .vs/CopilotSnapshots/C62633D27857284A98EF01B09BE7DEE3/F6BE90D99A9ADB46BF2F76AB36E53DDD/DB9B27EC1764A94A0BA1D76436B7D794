"""Keltner Pullback | EMA Stack Regime | Double Donchian | Pure Price Action | OBV Breakout | EMA200 Tap"""
from typing import List
import pandas as pd
from ..base import BaseStrategy, Signal, SignalType, StrategyConfig
from ...core.logger import logger

class KeltnerPullbackContinuation(BaseStrategy):
    def __init__(self, config: StrategyConfig = None):
        super().__init__(config)
    def get_required_indicators(self) -> List[str]:
        return ["keltner", "ema", "atr"]
    def generate_signals(self, df: pd.DataFrame) -> List[Signal]:
        signals, pos = [], None
        for i in range(1, len(df)):
            r = df.iloc[i]
            close = r["close"]
            kc_m, kc_l, kc_u = r.get("keltner_middle", close), r.get("keltner_lower", close), r.get("keltner_upper", close)
            ema200, atr = r.get("ema_200", close), r.get("atr", close*0.02)
            if pos is None:
                if close > ema200 and kc_l < close < kc_m:
                    sl, tp = self.calculate_exit_levels(SignalType.LONG, close, atr)
                    signals.append(Signal(SignalType.LONG, r["timestamp"], close, 0.75, sl, tp, {}))
                    pos = "LONG"
        logger.info(f"KeltnerPullbackContinuation: {len(signals)} signals")
        return signals

class EmaStackRegimeFlip(BaseStrategy):
    def __init__(self, config: StrategyConfig = None):
        super().__init__(config)
    def get_required_indicators(self) -> List[str]:
        return ["ema", "atr"]
    def generate_signals(self, df: pd.DataFrame) -> List[Signal]:
        signals, pos = [], None
        for i in range(1, len(df)):
            r, p = df.iloc[i], df.iloc[i-1]
            close, ema12, ema26, ema200 = r["close"], r.get("ema_12", r["close"]), r.get("ema_26", r["close"]), r.get("ema_200", r["close"])
            e12p, e26p = p.get("ema_12", close), p.get("ema_26", close)
            atr = r.get("atr", close*0.02)
            flip_bull = e12p <= e26p and ema12 > ema26 and close > ema200
            if pos is None and flip_bull:
                sl, tp = self.calculate_exit_levels(SignalType.LONG, close, atr)
                signals.append(Signal(SignalType.LONG, r["timestamp"], close, 0.8, sl, tp, {}))
                pos = "LONG"
        logger.info(f"EmaStackRegimeFlip: {len(signals)} signals")
        return signals

class DoubleDonchianPullback(BaseStrategy):
    def __init__(self, config: StrategyConfig = None):
        super().__init__(config)
    def get_required_indicators(self) -> List[str]:
        return ["donchian", "atr"]
    def generate_signals(self, df: pd.DataFrame) -> List[Signal]:
        signals, pos = [], None
        for i in range(1, len(df)):
            r = df.iloc[i]
            close, don_m = r["close"], r.get("donchian_middle", close)
            atr = r.get("atr", close*0.02)
            if pos is None and abs(close - don_m) < atr * 0.5:
                if close > don_m:
                    sl, tp = self.calculate_exit_levels(SignalType.LONG, close, atr)
                    signals.append(Signal(SignalType.LONG, r["timestamp"], close, 0.7, sl, tp, {}))
                    pos = "LONG"
        logger.info(f"DoubleDonchianPullback: {len(signals)} signals")
        return signals

class PurePriceActionDonchian(BaseStrategy):
    def __init__(self, config: StrategyConfig = None):
        super().__init__(config)
    def get_required_indicators(self) -> List[str]:
        return ["donchian", "atr"]
    def generate_signals(self, df: pd.DataFrame) -> List[Signal]:
        signals, pos = [], None
        for i in range(1, len(df)):
            r = df.iloc[i]
            close, don_u = r["close"], r.get("donchian_upper", close)
            atr = r.get("atr", close*0.02)
            if pos is None and close > don_u:
                sl, tp = self.calculate_exit_levels(SignalType.LONG, close, atr)
                signals.append(Signal(SignalType.LONG, r["timestamp"], close, 0.75, sl, tp, {}))
                pos = "LONG"
        logger.info(f"PurePriceActionDonchian: {len(signals)} signals")
        return signals

class ObvConfirmationBreakoutPlus(BaseStrategy):
    def __init__(self, config: StrategyConfig = None):
        super().__init__(config)
    def get_required_indicators(self) -> List[str]:
        return ["obv", "bollinger", "atr"]
    def generate_signals(self, df: pd.DataFrame) -> List<Signal]:
        signals, pos = [], None
        for i in range(5, len(df)):
            r = df.iloc[i]
            close, bb_u = r["close"], r.get("bb_upper", close)
            obv, atr = r.get("obv", 0), r.get("atr", close*0.02)
            obv_rising = obv > df.iloc[i-5].get("obv", 0)
            if pos is None and close > bb_u and obv_rising:
                sl, tp = self.calculate_exit_levels(SignalType.LONG, close, atr)
                signals.append(Signal(SignalType.LONG, r["timestamp"], close, 0.8, sl, tp, {}))
                pos = "LONG"
        logger.info(f"ObvConfirmationBreakoutPlus: {len(signals)} signals")
        return signals

class Ema200TapReversion(BaseStrategy):
    def __init__(self, config: StrategyConfig = None):
        super().__init__(config)
    def get_required_indicators(self) -> List[str]:
        return ["ema", "rsi", "atr"]
    def generate_signals(self, df: pd.DataFrame) -> List[Signal]:
        signals, pos = [], None
        for i in range(1, len(df)):
            r = df.iloc[i]
            close, low = r["close"], r["low"]
            ema200, rsi = r.get("ema_200", close), r.get("rsi", 50)
            atr = r.get("atr", close*0.02)
            tap_ema = abs(low - ema200) < atr * 0.5
            if pos is None and close > ema200 and tap_ema and 40 < rsi < 55:
                sl, tp = self.calculate_exit_levels(SignalType.LONG, close, atr)
                signals.append(Signal(SignalType.LONG, r["timestamp"], close, 0.8, sl, tp, {}))
                pos = "LONG"
        logger.info(f"Ema200TapReversion: {len(signals)} signals")
        return signals

__all__ = ["KeltnerPullbackContinuation", "EmaStackRegimeFlip", "DoubleDonchianPullback", "PurePriceActionDonchian", "ObvConfirmationBreakoutPlus", "Ema200TapReversion"]
