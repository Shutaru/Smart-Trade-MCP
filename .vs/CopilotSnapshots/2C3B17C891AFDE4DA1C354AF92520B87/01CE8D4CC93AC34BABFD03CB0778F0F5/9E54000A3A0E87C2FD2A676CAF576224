# -*- coding: utf-8 -*-
"""
Agent Orchestrator

Manages multiple autonomous trading agents.
Each agent is a dedicated process for one symbol + timeframe + strategy.
"""

import asyncio
import multiprocessing
import threading
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Optional
from uuid import uuid4
import signal
import sys
import os

from ..core.logger import logger
from .trading_agent import TradingAgent
from .agent_storage import AgentStorage


class AgentOrchestrator:
    """
    Central orchestrator for managing multiple trading agents.
    """

    def __init__(self, db_path: Path = Path("data/agents.db"), max_agents: int = 20, auto_restart: bool = True):
        self.agents: Dict[str, Dict[str, Any]] = {}
        self.storage = AgentStorage(db_path)
        self.max_agents = max_agents
        self.auto_restart = auto_restart
        self._lock = threading.Lock()
        self._monitor_thread = None
        self._stop_monitor = threading.Event()

        # Setup signal handlers
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)

        logger.info("=" * 80)
        logger.info("AGENT ORCHESTRATOR - INITIALIZED")
        logger.info(f"Max agents: {self.max_agents} | Auto-restart: {self.auto_restart}")
        logger.info("=" * 80)

        # Restore any active agents from storage (auto-restart behaviour)
        try:
            self._restore_active_agents()
        except Exception as e:
            logger.warning(f"Failed to restore agents on init: {e}")

        # Attach any external processes recorded in DB (pid) to orchestrator
        try:
            attached = self.reconcile_db_agents()
            if attached:
                logger.info(f"Attached external agents from DB on init: {attached}")
        except Exception as e:
            logger.debug(f"reconcile_db_agents failed on init: {e}")

        # Start monitor thread
        self._start_monitor()

    def _start_monitor(self):
        """Start background monitor thread to supervise agents."""
        if self._monitor_thread is None:
            self._monitor_thread = threading.Thread(target=self._monitor_agents_loop, daemon=True)
            self._monitor_thread.start()
            logger.info("Agent monitor thread started")

    def _monitor_agents_loop(self):
        """Loop that monitors agent processes and restarts if needed."""
        while not self._stop_monitor.is_set():
            try:
                with self._lock:
                    for agent_id, info in list(self.agents.items()):
                        proc = info.get("process")
                        status = info.get("status")
                        # If process died but agent is marked active, restart
                        if status == "active":
                            alive = False
                            try:
                                if proc and hasattr(proc, "is_alive"):
                                    alive = proc.is_alive()
                                elif proc and hasattr(proc, "pid"):
                                    # best-effort: check pid
                                    os.kill(proc.pid, 0)
                                    alive = True
                            except Exception:
                                alive = False

                            if not alive:
                                logger.warning(f"Agent {agent_id} process not alive. Auto-restart enabled={self.auto_restart}")
                                if self.auto_restart:
                                    try:
                                        cfg = info.get("config")
                                        logger.info(f"Restarting agent {agent_id}...")
                                        new_agent = TradingAgent(**cfg)
                                        new_proc = multiprocessing.Process(target=new_agent.run, name=f"Agent-{agent_id}")
                                        new_proc.start()
                                        info["agent"] = new_agent
                                        info["process"] = new_proc
                                        info["started_at"] = datetime.now()
                                        logger.info(f"Agent {agent_id} restarted (PID: {new_proc.pid})")
                                        # update storage started_at
                                        try:
                                            self.storage.update_status(agent_id, "active")
                                        except Exception:
                                            pass
                                        # persist pid
                                        try:
                                            self.storage.update_pid(agent_id, new_proc.pid)
                                        except Exception:
                                            pass
                                    except Exception as e:
                                        logger.error(f"Failed to restart agent {agent_id}: {e}")

            except Exception as e:
                logger.error(f"Error in monitor loop: {e}", exc_info=True)
            time.sleep(5)

    def _restore_active_agents(self):
        """Restore agents with status 'active' from storage at startup."""
        active_agents = self.storage.get_active_agents()
        restored = 0
        for a in active_agents:
            agent_id = a.get("agent_id")
            # Skip if already in memory
            if agent_id in self.agents:
                continue
            # Enforce max agents — count only in-memory active agents to avoid double-counting DB entries
            current_active = len([x for x in self.agents.values() if x.get("status") == "active"])
            if current_active >= self.max_agents:
                logger.warning(f"Max agents reached; skipping restore of {agent_id}")
                continue
            try:
                cfg = {
                    "agent_id": agent_id,
                    "symbol": a.get("symbol"),
                    "timeframe": a.get("timeframe"),
                    "strategy": a.get("strategy"),
                    "params": a.get("params") or {},
                    "risk_per_trade": a.get("risk_per_trade", 0.02),
                    "scan_interval_minutes": a.get("scan_interval_minutes", 15),
                }
                agent = TradingAgent(**cfg)
                process = multiprocessing.Process(target=agent.run, name=f"Agent-{agent_id}")
                process.start()
                self.agents[agent_id] = {
                    "agent": agent,
                    "process": process,
                    "config": cfg,
                    "started_at": datetime.now(),
                    "status": "active",
                }
                restored += 1
                logger.info(f"Restored agent {agent_id} (PID: {process.pid})")
                # persist pid
                try:
                    self.storage.update_pid(agent_id, process.pid)
                except Exception:
                    pass
            except Exception as e:
                logger.error(f"Failed to restore agent {agent_id}: {e}")
        if restored:
            logger.info(f"Restored {restored} active agents from storage")

    async def launch_agent(
        self,
        symbol: str,
        timeframe: str,
        strategy: str,
        params: Dict[str, Any],
        risk_per_trade: float = 0.02,
        scan_interval_minutes: int = 15,
        agent_id: Optional[str] = None,
    ) -> str:
        """Launch a new dedicated trading agent."""
        current_active = len([a for a in self.agents.values() if a.get("status") == "active"]) if self.agents else 0
        if current_active >= self.max_agents:
            raise RuntimeError(f"Max agents limit reached ({self.max_agents})")

        agent_id = agent_id or self._generate_agent_id(symbol, timeframe, strategy)

        logger.info(f"?? Launching agent: {agent_id}")
        logger.info(f"   Symbol: {symbol}")
        logger.info(f"   Timeframe: {timeframe}")
        logger.info(f"   Strategy: {strategy}")
        logger.info(f"   Scan interval: {scan_interval_minutes} min")

        agent_config = {
            "agent_id": agent_id,
            "symbol": symbol,
            "timeframe": timeframe,
            "strategy": strategy,
            "params": params,
            "risk_per_trade": risk_per_trade,
            "scan_interval_minutes": scan_interval_minutes,
        }

        try:
            existing = self.storage.get_agent(agent_id)
            if not existing:
                self.storage.add_agent(agent_config)
            else:
                self.storage.update_status(agent_id, "active")
        except Exception as e:
            logger.warning(f"Failed to persist agent {agent_id}: {e}")

        agent = TradingAgent(**agent_config)
        process = multiprocessing.Process(target=agent.run, name=f"Agent-{agent_id}")
        process.start()

        with self._lock:
            self.agents[agent_id] = {
                "agent": agent,
                "process": process,
                "config": agent_config,
                "started_at": datetime.now(),
                "status": "active",
            }
        try:
            self.storage.update_pid(agent_id, process.pid)
        except Exception:
            pass
        logger.info(f"? Agent {agent_id} launched (PID: {process.pid})")
        return agent_id

    def stop_agent(self, agent_id: str, reason: Optional[str] = None):
        if agent_id not in self.agents:
            try:
                self.storage.update_status(agent_id, "stopped", reason)
            except Exception:
                pass
            raise ValueError(f"Agent {agent_id} not found")

        logger.info(f"?? Stopping agent: {agent_id}")
        if reason:
            logger.info(f"   Reason: {reason}")

        agent_info = self.agents[agent_id]
        proc = agent_info.get("process")
        if proc and hasattr(proc, "is_alive") and proc.is_alive():
            proc.terminate()
            proc.join(timeout=5)
            if proc.is_alive():
                try:
                    proc.kill()
                except Exception:
                    pass

        agent_info["status"] = "stopped"
        agent_info["stopped_at"] = datetime.now()
        agent_info["stop_reason"] = reason

        try:
            self.storage.update_status(agent_id, "stopped", reason)
        except Exception:
            pass

        logger.info(f"? Agent {agent_id} stopped")

    def get_agent_info(self, agent_id: str) -> Dict[str, Any]:
        if agent_id not in self.agents:
            return self.storage.get_agent(agent_id)

        agent_info = self.agents[agent_id]
        proc = agent_info.get("process")
        is_alive = False
        pid = None
        try:
            if proc and hasattr(proc, "is_alive"):
                is_alive = proc.is_alive()
                pid = proc.pid if hasattr(proc, "pid") else None
            elif proc and hasattr(proc, "pid"):
                # External proxy
                is_alive = proc.is_alive()
                pid = proc.pid
        except Exception:
            is_alive = False

        return {
            "agent_id": agent_id,
            "symbol": agent_info["config"]["symbol"],
            "timeframe": agent_info["config"]["timeframe"],
            "strategy": agent_info["config"]["strategy"],
            "status": agent_info["status"],
            "pid": pid,
            "started_at": agent_info["started_at"].isoformat() if isinstance(agent_info.get("started_at"), datetime) else agent_info.get("started_at"),
            "is_alive": is_alive,
        }

    def get_agent_performance(self, agent_id: str) -> Dict[str, Any]:
        trades = self.storage.get_agent_trades(agent_id)
        if not trades:
            return {
                "total_trades": 0,
                "winning_trades": 0,
                "losing_trades": 0,
                "win_rate": 0,
                "total_pnl": 0,
                "sharpe_ratio": 0,
                "max_drawdown": 0,
            }

        total_trades = len(trades)
        winning_trades = sum(1 for t in trades if t.get("pnl") and t["pnl"] > 0)
        losing_trades = sum(1 for t in trades if t.get("pnl") and t["pnl"] < 0)
        win_rate = (winning_trades / total_trades * 100) if total_trades > 0 else 0
        total_pnl = sum((t.get("pnl") or 0) for t in trades)
        wins = [t.get("pnl") for t in trades if t.get("pnl") and t["pnl"] > 0]
        losses = [t.get("pnl") for t in trades if t.get("pnl") and t["pnl"] < 0]
        avg_win = sum(wins) / len(wins) if wins else 0
        avg_loss = sum(losses) / len(losses) if losses else 0
        import numpy as np
        returns = [t.get("pnl") or 0 for t in trades]
        sharpe = (np.mean(returns) / np.std(returns)) if len(returns) > 1 else 0
        cumulative_pnl = np.cumsum(returns)
        running_max = np.maximum.accumulate(cumulative_pnl)
        drawdown = cumulative_pnl - running_max
        max_drawdown = np.min(drawdown) if len(drawdown) > 0 else 0
        equity_series = []
        try:
            sorted_trades = sorted(trades, key=lambda t: t.get("exit_time") or t.get("entry_time"))
            cum = 0.0
            equity_series.append({"time": datetime.now().isoformat(), "value": round(cum, 2)})
            for t in sorted_trades:
                pnl = float(t.get("pnl") or 0)
                cum += pnl
                ts = t.get("exit_time") or t.get("entry_time")
                try:
                    ts_iso = ts if isinstance(ts, str) else str(ts)
                except Exception:
                    ts_iso = datetime.now().isoformat()
                equity_series.append({"time": ts_iso, "value": round(cum, 2)})
        except Exception:
            equity_series = [{"time": datetime.now().isoformat(), "value": 0}]

        return {
            "total_trades": total_trades,
            "winning_trades": winning_trades,
            "losing_trades": losing_trades,
            "win_rate": round(win_rate, 2),
            "total_pnl": round(total_pnl, 2),
            "avg_win": round(avg_win, 2),
            "avg_loss": round(avg_loss, 2),
            "sharpe_ratio": round(sharpe, 2),
            "max_drawdown": round(max_drawdown, 2),
            "profit_factor": round(abs(sum(wins) / sum(losses)), 2) if losses else 0,
            "equity_series": equity_series,
        }

    def get_all_agents(self) -> List[Dict[str, Any]]:
        agents_map: Dict[str, Dict[str, Any]] = {}
        for agent_id, info in self.agents.items():
            perf = self.get_agent_performance(agent_id)
            proc = info.get("process")
            pid = proc.pid if proc and hasattr(proc, "pid") else None
            is_alive = False
            try:
                is_alive = proc.is_alive() if proc and hasattr(proc, "is_alive") else False
            except Exception:
                is_alive = False
            agent_data = {
                "agent_id": agent_id,
                **info["config"],
                "status": info["status"],
                "pid": pid,
                "started_at": info["started_at"].isoformat() if isinstance(info.get("started_at"), datetime) else info.get("started_at"),
                "is_alive": is_alive,
                "performance": perf,
            }
            agents_map[agent_id] = agent_data
        db_active = self.storage.get_active_agents()
        for agent in db_active:
            aid = agent.get("agent_id")
            if not aid or aid in agents_map:
                continue
            perf = self.get_agent_performance(aid)
            agent_data = {
                "agent_id": aid,
                "symbol": agent.get("symbol"),
                "timeframe": agent.get("timeframe"),
                "strategy": agent.get("strategy"),
                "status": agent.get("status", "active"),
                "pid": agent.get("pid"),
                "started_at": agent.get("started_at"),
                "is_alive": False,
                "performance": perf,
            }
            agents_map[aid] = agent_data
        stopped = self.storage.get_stopped_agents()
        for agent in stopped:
            aid = agent.get("agent_id")
            if not aid or aid in agents_map:
                continue
            perf = self.get_agent_performance(aid)
            agent_data = {**agent, "performance": perf}
            agents_map[aid] = agent_data

        return list(agents_map.values())

    class ExternalProcessProxy:
        """Lightweight proxy representing an external process started earlier.

        Provides minimal .pid and .is_alive() for orchestrator to treat the process as running.
        """
        def __init__(self, pid: int):
            self.pid = int(pid)

        def is_alive(self):
            try:
                # signal 0 check
                os.kill(self.pid, 0)
                return True
            except Exception:
                return False

    def reconcile_db_agents(self) -> List[str]:
        """Attach active agents found in DB (by pid) into the orchestrator.agents map

        For agents that were started in previous process runs and still exist, this will
        create an ExternalProcessProxy so they become visible to the API without
        respawning new processes.

        Returns list of agent_ids attached.
        """
        attached = []
        with self._lock:
            db_active = self.storage.get_active_agents()
            for a in db_active:
                aid = a.get('agent_id')
                if not aid or aid in self.agents:
                    continue
                pid = a.get('pid')
                if not pid:
                    continue
                try:
                    pid = int(pid)
                except Exception:
                    continue
                # check if process exists
                proxy = AgentOrchestrator.ExternalProcessProxy(pid)
                if proxy.is_alive():
                    cfg = {
                        'agent_id': aid,
                        'symbol': a.get('symbol'),
                        'timeframe': a.get('timeframe'),
                        'strategy': a.get('strategy'),
                        'params': a.get('params') or {},
                        'risk_per_trade': a.get('risk_per_trade', 0.02),
                        'scan_interval_minutes': a.get('scan_interval_minutes', 15),
                    }
                    self.agents[aid] = {
                        'agent': None,
                        'process': proxy,
                        'config': cfg,
                        'started_at': a.get('started_at') or datetime.now(),
                        'status': a.get('status', 'active'),
                    }
                    attached.append(aid)
                    logger.info(f"Attached external agent {aid} (PID: {pid}) to orchestrator")
        return attached

    def update_agent_params(self, agent_id: str, params: Dict[str, Any]):
        """
        Update agent parameters on-the-fly.

        Note: This requires agent to support hot-reload.
        """
        if agent_id not in self.agents:
            raise ValueError(f"Agent {agent_id} not found")

        # Update config
        self.agents[agent_id]["config"]["params"].update(params)

        # Update database
        self.storage.update_params(agent_id, params)

        # Signal agent to reload (if supported)
        # TODO: Implement IPC for parameter updates

        logger.info(f"? Updated params for agent {agent_id}")

    def get_portfolio_summary(self) -> Dict[str, Any]:
        """Get high-level portfolio summary."""
        agents = self.get_all_agents()

        if not agents:
            return {
                "total_agents": 0,
                "active_agents": 0,
                "total_pnl": 0,
                "total_trades": 0,
                "overall_win_rate": 0,
            }

        active = [a for a in agents if a["status"] == "active"]

        total_pnl = sum(a.get("total_pnl", 0) for a in agents)
        total_trades = sum(a.get("total_trades", 0) for a in agents)
        total_wins = sum(a.get("winning_trades", 0) for a in agents)

        overall_win_rate = (total_wins / total_trades * 100) if total_trades > 0 else 0

        # Best and worst agents
        agents_with_pnl = [a for a in agents if a.get("total_pnl", 0) != 0]
        best_agent = max(agents_with_pnl, key=lambda x: x.get("total_pnl", 0)) if agents_with_pnl else None
        worst_agent = min(agents_with_pnl, key=lambda x: x.get("total_pnl", 0)) if agents_with_pnl else None

        return {
            "total_agents": len(agents),
            "active_agents": len(active),
            "stopped_agents": len(agents) - len(active),
            "total_pnl": round(total_pnl, 2),
            "total_trades": total_trades,
            "overall_win_rate": round(overall_win_rate, 2),
            "best_agent": {
                "agent_id": best_agent["agent_id"],
                "symbol": best_agent["symbol"],
                "strategy": best_agent["strategy"],
                "pnl": best_agent["total_pnl"],
            } if best_agent else None,
            "worst_agent": {
                "agent_id": worst_agent["agent_id"],
                "symbol": worst_agent["symbol"],
                "strategy": worst_agent["strategy"],
                "pnl": worst_agent["total_pnl"],
            } if worst_agent else None,
        }

    def _generate_agent_id(self, symbol: str, timeframe: str, strategy: str) -> str:
        """Generate unique agent ID."""
        symbol_clean = symbol.replace("/", "_").replace(":", "_")
        unique_suffix = uuid4().hex[:6]
        return f"agent_{symbol_clean}_{timeframe}_{strategy}_{unique_suffix}"

    def _signal_handler(self, signum, frame):
        """Handle shutdown signals - stop all agents gracefully."""
        logger.info("Orchestrator received shutdown signal")
        self.shutdown()
        sys.exit(0)

    def shutdown(self):
        """Gracefully shutdown all agents."""
        logger.info("=" * 80)
        logger.info("SHUTTING DOWN ORCHESTRATOR")
        logger.info("=" * 80)

        for agent_id in list(self.agents.keys()):
            try:
                self.stop_agent(agent_id, reason="Orchestrator shutdown")
            except Exception as e:
                logger.error(f"Error stopping agent {agent_id}: {e}")

        logger.info("? All agents stopped")


if __name__ == "__main__":
    # Example usage
    import asyncio

    async def test():
        orchestrator = AgentOrchestrator()

        # Launch test agent
        agent_id = await orchestrator.launch_agent(
            symbol="BTC/USDT",
            timeframe="1h",
            strategy="cci_extreme_snapback",
            params={"cci_period": 20},
            scan_interval_minutes=1,
        )

        print(f"Launched: {agent_id}")

        # Wait a bit
        await asyncio.sleep(5)

        # Get performance
        perf = orchestrator.get_agent_performance(agent_id)
        print(f"Performance: {perf}")

        # Stop agent
        orchestrator.stop_agent(agent_id, "Test complete")

    asyncio.run(test())
