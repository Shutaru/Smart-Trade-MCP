# -*- coding: utf-8 -*-
"""
Paper Trading API Router

Provides endpoints to start/stop/list paper trading bots and a WebSocket
for realtime updates. Uses AgentOrchestrator and AgentStorage already
present in the project for process management and persistence.
"""

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, HTTPException
from typing import Dict, Any, Optional
from datetime import datetime
import asyncio

from ...agent.orchestrator import AgentOrchestrator
from ...paper.broadcaster import get_broadcaster

router = APIRouter()

# Single global orchestrator for the API
_orchestrator = AgentOrchestrator()

# ---- Models are simple dict bodies for now

@router.post("/bots")
async def start_bot(payload: Dict[str, Any]):
    """Start a new paper trading bot.

    Expected payload keys:
    - symbol (str)
    - timeframe (str)
    - strategy (str)
    - params (dict, optional)
    - risk_per_trade (float, optional)
    - scan_interval_minutes (int, optional)
    """
    symbol = payload.get("symbol")
    timeframe = payload.get("timeframe")
    strategy = payload.get("strategy")
    params = payload.get("params", {})
    risk = float(payload.get("risk_per_trade", 0.02))
    scan = int(payload.get("scan_interval_minutes", 15))

    if not symbol or not timeframe or not strategy:
        raise HTTPException(status_code=400, detail="symbol, timeframe and strategy are required")

    try:
        agent_id = await _orchestrator.launch_agent(
            symbol=symbol,
            timeframe=timeframe,
            strategy=strategy,
            params=params,
            risk_per_trade=risk,
            scan_interval_minutes=scan
        )

        info = _orchestrator.get_agent_info(agent_id)

        return {
            "success": True,
            "agent_id": agent_id,
            "started_at": info.get("started_at"),
            "pid": info.get("pid"),
            "status": info.get("status")
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/bots/{agent_id}/stop")
async def stop_bot(agent_id: str, payload: Optional[Dict[str, Any]] = None):
    reason = None
    if payload:
        reason = payload.get("reason")

    try:
        _orchestrator.stop_agent(agent_id, reason=reason)
        return {"success": True, "agent_id": agent_id, "status": "stopped"}
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/bots")
async def list_bots():
    try:
        agents = _orchestrator.get_all_agents()
        normalized = []
        for a in agents:
            perf = {}
            try:
                perf = _orchestrator.get_agent_performance(a.get("agent_id")) or {}
            except Exception:
                perf = {}

            normalized.append({
                "agent_id": a.get("agent_id"),
                "symbol": a.get("symbol"),
                "timeframe": a.get("timeframe"),
                "strategy": a.get("strategy"),
                "status": a.get("status"),
                "pid": a.get("pid"),
                "started_at": a.get("started_at"),
                "is_alive": a.get("is_alive", False),
                "total_trades": a.get("total_trades", 0),
                "total_pnl": a.get("total_pnl", 0),
                "performance": perf,
            })

        return {"success": True, "total": len(normalized), "agents": normalized}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/bots/active")
async def list_active_bots():
    """Return only active agents (including DB-active even if not in-memory)."""
    try:
        agents = _orchestrator.get_all_agents()
        active = [a for a in agents if a.get("status") == "active"]
        # Normalize to expected frontend shape and include performance
        normalized = []
        for a in active:
            perf = {}
            try:
                perf = _orchestrator.get_agent_performance(a.get("agent_id")) or {}
            except Exception:
                perf = {}

            normalized.append({
                "agent_id": a.get("agent_id"),
                "symbol": a.get("symbol"),
                "timeframe": a.get("timeframe"),
                "strategy": a.get("strategy"),
                "status": a.get("status"),
                "pid": a.get("pid"),
                "started_at": a.get("started_at"),
                "is_alive": a.get("is_alive", False),
                "total_trades": a.get("total_trades", 0),
                "total_pnl": a.get("total_pnl", 0),
                "performance": perf,
            })

        return {"success": True, "total": len(normalized), "agents": normalized}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/bots/{agent_id}")
async def get_bot(agent_id: str):
    try:
        info = _orchestrator.get_agent_info(agent_id)
        perf = _orchestrator.get_agent_performance(agent_id)
        return {"success": True, "agent": info, "performance": perf}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.websocket("/ws/paper/{agent_id}")
async def ws_paper_updates(websocket: WebSocket, agent_id: str):
    """WebSocket endpoint that streams agent updates.

    The implementation uses broadcaster to stream events/updates to
    connected clients.
    """
    await websocket.accept()
    broadcaster = get_broadcaster()
    queue = broadcaster.subscribe(agent_id)
    try:
        # Send initial snapshot
        info = _orchestrator.get_agent_info(agent_id)
        perf = _orchestrator.get_agent_performance(agent_id)
        trades = _orchestrator.storage.get_agent_trades(agent_id)
        snapshot = {"type": "snapshot", "timestamp": datetime.utcnow().isoformat(), "agent": info, "performance": perf, "trades": trades}
        await websocket.send_json(snapshot)

        while True:
            # wait for next event from broadcaster queue
            ev = await queue.get()
            try:
                await websocket.send_json({"type": "event", "event": ev})
            except Exception:
                # client likely disconnected
                break

    except WebSocketDisconnect:
        return
    finally:
        broadcaster.unsubscribe(agent_id, queue)
        try:
            await websocket.close()
        except Exception:
            pass


@router.get("/debug")
async def debug_info():
    """Debug endpoint: returns storage DB path and raw agents from DB and orchestrator."""
    try:
        storage = _orchestrator.storage
        db_path = str(storage.db_path)
        active_db = storage.get_active_agents()
        stopped_db = storage.get_stopped_agents()
        # orchestrator in-memory agents
        in_memory = list(_orchestrator.agents.keys())
        all_via_orch = _orchestrator.get_all_agents()
        return {
            "db_path": db_path,
            "active_db_count": len(active_db),
            "stopped_db_count": len(stopped_db),
            "in_memory_agents": in_memory,
            "agents_via_orchestrator_count": len(all_via_orch),
            "active_db": active_db,
            "stopped_db": stopped_db,
            "agents_via_orchestrator": all_via_orch,
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
