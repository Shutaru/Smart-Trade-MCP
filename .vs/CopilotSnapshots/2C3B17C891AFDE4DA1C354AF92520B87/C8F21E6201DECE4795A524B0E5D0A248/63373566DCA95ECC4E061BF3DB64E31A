"""
Test DataManager.fetch_historical() directly

Tests the data fetching layer to isolate if the issue
is in the DataManager itself or in the MCP integration.
"""

import asyncio
import sys
from pathlib import Path
from datetime import datetime, timedelta

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))

from src.core.data_manager import DataManager


async def main():
    """Test DataManager fetch_historical directly."""
    
    print("=" * 80)
    print("DATA MANAGER FETCH TEST")
    print("=" * 80)
    print()
    
    # Calculate dates
    end_dt = datetime.now()
    start_dt = end_dt - timedelta(days=365)  # 1 year
    
    print(f"Fetching data for BTC/USDT 1h")
    print(f"Start: {start_dt}")
    print(f"End:   {end_dt}")
    print(f"Expected: ~8760 candles (365 days * 24 hours)")
    print()
    print("=" * 80)
    print()
    
    # Create DataManager
    dm = DataManager()
    
    try:
        print("?? Fetching historical data...")
        print()
        
        df = await dm.fetch_historical(
            symbol='BTC/USDT',
            timeframe='1h',
            start_date=start_dt,
            end_date=end_dt,
            max_candles=10000,
        )
        
        await dm.close()
        
        print()
        print("=" * 80)
        print("FETCH RESULTS:")
        print("=" * 80)
        print(f"Candles fetched:    {len(df)}")
        print(f"Start timestamp:    {df['timestamp'].iloc[0]}")
        print(f"End timestamp:      {df['timestamp'].iloc[-1]}")
        print()
        
        actual_days = (df['timestamp'].iloc[-1] - df['timestamp'].iloc[0]).days
        print(f"Actual period:      {actual_days} days")
        print(f"Requested period:   {(end_dt - start_dt).days} days")
        print(f"Coverage:           {actual_days / 365 * 100:.1f}%")
        print()
        
        print(f"First close price:  ${df['close'].iloc[0]:.2f}")
        print(f"Last close price:   ${df['close'].iloc[-1]:.2f}")
        print()
        print("=" * 80)
        print()
        
        # Validation
        print("VALIDATION:")
        print("=" * 80)
        
        if len(df) >= 8000:
            print(f"? Candle count: {len(df)} (PASS)")
        else:
            print(f"? Candle count: {len(df)} (FAIL - expected ~8760)")
        
        if actual_days >= 350:
            print(f"? Days coverage: {actual_days} (PASS)")
        else:
            print(f"? Days coverage: {actual_days} (FAIL - expected ~365)")
        
        print("=" * 80)
        print()
        
        if len(df) >= 8000 and actual_days >= 350:
            print("?? DATA MANAGER TEST PASSED!")
            print()
            print("Conclusion: DataManager works correctly.")
            print("Issue must be in MCP protocol integration.")
            return True
        else:
            print("?? DATA MANAGER TEST FAILED!")
            print()
            print("Possible causes:")
            print("  1. CCXT rate limiting")
            print("  2. Database cache returning old data")
            print("  3. Pagination logic issue")
            print()
            print("Next step: Clear cache and retry")
            print("  rm data/market/binance/BTC_USDT_1h.db")
            return False
            
    except Exception as e:
        await dm.close()
        print(f"? ERROR: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    success = asyncio.run(main())
    sys.exit(0 if success else 1)
