"""
Test MCP Backtest Tool Directly (without MCP protocol)

This script calls the backtest tool function directly to verify
it works correctly when not going through the MCP protocol.
"""

import asyncio
import sys
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))

from src.mcp_server.tools.backtest import backtest_strategy


async def main():
    """Test backtest tool directly."""
    
    print("=" * 80)
    print("DIRECT BACKTEST TOOL TEST")
    print("=" * 80)
    print()
    print("Testing: backtest_strategy() called directly (no MCP)")
    print("Expected: ~364 days, ~8760 candles, 20+ trades")
    print()
    print("=" * 80)
    print()
    
    # Call backtest tool WITHOUT start_date/end_date
    # (should auto-fetch 1 year)
    result = await backtest_strategy(
        strategy_name="atr_expansion_breakout",
        symbol="BTC/USDT",
        timeframe="1h",
        # start_date=None,  # Implicit
        # end_date=None,    # Implicit
    )
    
    print()
    print("=" * 80)
    print("RESULTS:")
    print("=" * 80)
    print(f"Tool Version:       {result.get('tool_version')}")
    print(f"Strategy:           {result.get('strategy')}")
    print(f"Symbol:             {result.get('symbol')}")
    print(f"Timeframe:          {result.get('timeframe')}")
    print()
    print(f"Start Date:         {result.get('start_date')}")
    print(f"End Date:           {result.get('end_date')}")
    print()
    print(f"Days Tested:        {result.get('days_tested')}")
    print(f"Candles Tested:     {result.get('candles_tested')}")
    print(f"Requested Days:     {result.get('requested_days', 'N/A')}")
    print(f"Data Coverage:      {result.get('data_coverage_pct', 'N/A')}%")
    print()
    print(f"Total Trades:       {result.get('total_trades')}")
    print(f"Total Return:       {result.get('total_return'):.2f}%")
    print(f"Win Rate:           {result.get('metrics', {}).get('win_rate', 0):.1f}%")
    print(f"Sharpe Ratio:       {result.get('metrics', {}).get('sharpe_ratio', 0):.2f}")
    print()
    print("=" * 80)
    print()
    
    # Verify expectations
    days_tested = result.get('days_tested', 0)
    candles_tested = result.get('candles_tested', 0)
    total_trades = result.get('total_trades', 0)
    
    print("VALIDATION:")
    print("=" * 80)
    
    if days_tested >= 350:
        print(f"? Days tested: {days_tested} (PASS - expected ~364)")
    else:
        print(f"? Days tested: {days_tested} (FAIL - expected ~364)")
    
    if candles_tested >= 8000:
        print(f"? Candles tested: {candles_tested} (PASS - expected ~8760)")
    else:
        print(f"? Candles tested: {candles_tested} (FAIL - expected ~8760)")
    
    if total_trades >= 10:
        print(f"? Total trades: {total_trades} (PASS - expected 20+)")
    else:
        print(f"? Total trades: {total_trades} (FAIL - expected 20+)")
    
    print("=" * 80)
    print()
    
    if 'error' in result:
        print(f"? ERROR: {result['error']}")
        return False
    
    # Overall result
    if days_tested >= 350 and candles_tested >= 8000:
        print("?? TEST PASSED: Direct tool call works correctly!")
        print()
        print("Next step: Test via MCP protocol (Claude Desktop)")
        return True
    else:
        print("?? TEST FAILED: Issue exists even without MCP")
        print()
        print("Next step: Debug DataManager.fetch_historical()")
        return False


if __name__ == "__main__":
    success = asyncio.run(main())
    sys.exit(0 if success else 1)
